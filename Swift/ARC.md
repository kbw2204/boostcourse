## ARC

ARC는 Automatic Reference Counting의 약자로 **자동으로 메모리를 관리해주는 방식**입니다. ARC는 더이상 필요하지 않는 클래스의 인스턴스를 메모리에서 해제하는 방식으로 동작합니다.

### 필요 이유

struct과 같은 값 타입은 값을 전달할 때마다 값을 복사해 전달하는것과 달리 class와 같은 참조 타입은 하나의 인스턴스가 참조를 통해 참조가 되기 떄문에 언제 메모리에서 해제되는지가 중요합니다.

### ARC 참조 카운팅 시점

자바에도 ARC와 같은 메모리 관리 기법으로 가비지 컬렉션이 있는데, 가비지 컬렉션과는 달리 ARC는 컴파일 시점에서 동작하여 참조 카운팅을 추적하여 0이 되는 시점에 자동으로 해지합니다.

### 장점과 단점

- 장점
  - 컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어서 인스턴스가 언제 메모리에서 해제될지 예츨할 수가 있습니다.
  - 컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있기 때문에 메모리 관리를 위한 시스템 자원을 추가할 필요가 없습니다.
- 단점
  - ARC의 자동 규칙을 모르고 사용하면 인스턴스가 메모리에서 영영 해제되지 않을 수가 있습니다.

> NOTE: 그렇기 때문에 원하는 방향으로 메모리 관리가 이우어지려면 ARC에 명확한 힌트를 주는게 중요합니다.

### ARC 작동 방식

클래스의 새로운 인스턴스를 만들 때 마다 ARC는 인스턴스에 대한 정보를 정장하기 위해 메모리 덩어리를 할당한다.
이 메모리는 인스턴스의 저장 프로퍼티와 연관된 값과 함께 인스턴스의 타입에 관한 정보를 유지한다.
인스턴스가 더이상 필요하지 않을 때 ARC는 메모리를 다른 목적으로 사용할 수 있도록 인스턴스에 의해 사용된 메모리를 해제한다.
> 클래스 인스턴스가 더 이상 필요하지 않을 때 메모리 공간을 가지지 않는 것을 보장한다.

**하지만** ARC가 사용중에 있는데 인스턴스를 할당 해제하면 인스턴스의 프로퍼티 접근이나 인스턴스 메소드의 더 이상 호출할 수 없다. 만약 접근한다면 크래쉬가 난다.

그래서 필요한 인스턴스가 사라지지 않는지 확인해야 하고,
ARC는 각 클래스 인스턴스에 현재 참조중인 프로퍼티, 상수, 변수를 추적한다. ARC는 인스턴스에 대해 활성화된 참조가 하나라도 있다면 할당을 해제하지 않는다.

프로퍼티, 상수, 변수에 클래스 인스턴스를 할당할 때마다 프로퍼티, 상수, 변수는 인스턴스에 강한 참조(strong reference)를 만들게 된다.
그 참조는 **강한 참조**로 호출되기 때문에, 인스턴스를 강하게 유지하여 강한 참조가 남아 있는 만큼은 메모리 할당을 해지하지 않는다.

### 강한참조

인스턴스가 계속해서 남아있어야 하는 명분을 만들어 주는 것이 바로 **강한참조(Strong)**이다. 인스턴스는 참조 횟수가 0이 되는 순간 메모리에서 해제되는데, 강한참조를 사용하게 되면, 참조횟수가 1 증가합니다. 또한 강한참조를 사용하는 프로퍼티, 변수, 상수 등에 nil을 할당해주면 원래 자신에게 할당되어 있던 인스턴스의 참조 횟수가 1 감소합니다.
> 참조의 디폴트값은 강한참조입니다. 즉 클래스 타입의 프로퍼티, 변수, 상수 등을 선언 할 때 식별자를 명시하지 않으면 강한참조를 합니다.

### 강한참조 순환문제

강한참조의 규칙을 모르고 복합적으로 강한참조를 사용한다면 문제가 발생할 수 있습니다. 인스턴스끼리 서로가 서로를 강한참조를 할 때 **강한참조 순환**이 일어나는데,
이렇게 되면 이 순환 참조에 연관된 객체들은 레퍼런스 카운트가 0에 도달하지 않게 되어 메모리 누수가 발생하게 됩니다. **그래서**
Swift와 같이 ARC를 기반으로 하는 메모리 관리 모델에서는 어떻게 하면 강한 순환 참조를 발생시키지 않도록 하느냐가 메모리 관리의 해결책이고 이를 해결하기 위한 방법으로 **약한참조(weak)** 방법이 있습니다.

### 약한참조(weak)

약한참조는 강한참조와 달리 자신이 참조하는 인스턴스의 참조 횟수를 증가시키지 않습니다. 참조타입의 프로퍼티나 변수의 선언 앞에 weak 키워드를 써주면 그 프로퍼티나 변수는 자신이 참조하는 인스턴스를 약한참조합니다.

약한참조는 참조하는 인스턴스를 강하게 유지하지 않는 참조이며,
다른 인스턴스의 생명주기가 짦을 때 사용합니다.
참조하고 있는 인스턴스를 강하게 유지하지 않기 때문에,
약한 참조로 참조하는 동안 인스턴스가 메모리 해제되는 것이 가능하고
참조하는 인스턴스가 메모리에서 해제되면,
ARC는 자동으로 약한참조를 nil로 설정합니다.
> NOTE: ARC가 약한 참조를 nil로 설정했을 때, 프로퍼티 옵저버는 호출되지 않습니다.

> NOTE: 약한참조는 상수에서 쓰일 수 없습니다. 만약 자신이 참조하던 인스턴스가 메모리에서 해제된다면 nil이 할당될 수 있어야 하기 때문입니다. 그래서 약한참조를 할 때는 자신의 값을 변경할 수 있는 변수로 선언해야 합니다. 

### unowned

언노운 또한 마찬가지로 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않습니다.(이 키워드는 논옵셔널 타입에만 된다)
특이한 점은 객체가 ARC에 의해 메모리가 헤제되더라도 해당 객체 값이 존재하는 것으로 인지하여, 해당 객체에 액세스를 할 경우 런타임 오류를 발생시킨다..고 하네요..

> 음.. 그럼 언노운은 왜쓰는걸까?.. =_=


#### 참고

- 야곰의 Swift 책
- [Hyejun Jang 블로그](http://jhyejun.com/blog/memory-management-arc)

[돌아가기 > 배우는 내용](#배우는-내용)

